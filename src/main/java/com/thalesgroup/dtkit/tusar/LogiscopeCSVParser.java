/*******************************************************************************
 * Copyright (c) 2011 Thales Corporate Services SAS                             *
 * Author : Aravindan Mahendran                                                 *
 *                                                                              *
 * Permission is hereby granted, free of charge, to any person obtaining a copy *
 * of this software and associated documentation files (the "Software"), to deal*
 * in the Software without restriction, including without limitation the rights *
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell    *
 * copies of the Software, and to permit persons to whom the Software is        *
 * furnished to do so, subject to the following conditions:                     *
 *                                                                              *
 * The above copyright notice and this permission notice shall be included in   *
 * all copies or substantial portions of the Software.                          *
 *                                                                              *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR   *
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,     *
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  *
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER       *
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,*
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN    *
 * THE SOFTWARE.                                                                *
 *******************************************************************************/

package com.thalesgroup.dtkit.tusar;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;

import com.thalesgroup.tusar.size.v1.SizeComplexType;
import com.thalesgroup.tusar.v7.Tusar;
import com.thalesgroup.tusar.violations.v4.ViolationsComplexType;

public class LogiscopeCSVParser {

	public static final String CSV_SEPARATOR = ";";

	private static final String TUSAR_VERSION = "7.0";

	private static final String TUSAR_XMLNS_XSI = "http://www.w3.org/2001/XMLSchema-instance";

	//These maps contain the Logiscope metrics managed by TUSAR
	private static final Map<String,String> functionManagedMetrics = new HashMap<String, String>();
	private static final Map<String,String> moduleManagedMetrics = new HashMap<String, String>();
	private static final Map<String,String> applicationManagedMetrics = new HashMap<String, String>();
	private static final Map<String,String> packageManagedMetrics = new HashMap<String, String>();//Not used for the moment...
	private static final Map<String,String> classManagedMetrics = new HashMap<String, String>();//Not used for the moment...

	//This list is used to deal with the violation column name present in the violation
	private static final Set<String> violationsColumnNames = new HashSet<String>();

	private static final int FILE_NAME_INDEX = 0;

	//Constants for the violation part
	private static final String FILE_COLUMN_NAME = "File";
	private static final String LINE_COLUMN_NAME = "Line";
	private static final String RULE_COLUMN_NAME = "Rule";
	private static final String DESCRIPTION_COLUMN_NAME = "Description";
	

	/**
	 * Filling the managed metrics maps.
	 * If you want to add a new Logiscope metric, just put it in the corresponding map : if you add a new module metric, put it in moduleManagedMetrics;
	 * For example :
	 * -you want to add the metric called md_x which is in the Module results generated by Logiscope : moduleManagedMetrics("md_x","TUSAR_CORRESPONDING_MEASURE_VALUE").
	 */
	static {
		functionManagedMetrics.put("ct_vg", "COMPLEXITY");
		functionManagedMetrics.put("ct_cyclo", "COMPLEXITY");
		functionManagedMetrics.put("VG", "COMPLEXITY");
		functionManagedMetrics.put("lc_stat", "INSTRUCTIONS");
		functionManagedMetrics.put("STMT", "INSTRUCTIONS");
		moduleManagedMetrics.put("md_line", "LOC");
		applicationManagedMetrics.put("ap_sline", "LOC");

		violationsColumnNames.add(FILE_COLUMN_NAME);
		violationsColumnNames.add(LINE_COLUMN_NAME);
		violationsColumnNames.add(RULE_COLUMN_NAME);
		violationsColumnNames.add(DESCRIPTION_COLUMN_NAME);
	}


	/**
	 * Read a csv file generated by Logiscope (File -> Export -> CSV Format -> ...) and return a list of string arrays (each array represents a line of the CSV file)
	 * @param csvFile The CSV file generated by Logiscope to read
	 * @return a list of String arrays which contains all values of the CSV file
	 */
	private static List<String[]> extractFromCSV(File csvFile){
		ArrayList<String[]> list = new ArrayList<String[]>();
		try {
			Scanner scanner = new Scanner(csvFile);
			while (scanner.hasNextLine()){
				String line = scanner.nextLine();
				list.add(line.split(CSV_SEPARATOR));
			}

		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		return list;
	}

	/**
	 * Replace double quotes by simple quotes.
	 * @param message The string where double quotes need to be replaced
	 * @return The string where double quotes has been replaced
	 */
	private static String replaceDoubleQuotes(String message){
		return message.replace('\"', '\'');
	}

	/**
	 * Creates an XML file from a TUSAR V7 node by calling the function marshal() of JAXB Marshaller
	 * @param node TUSAR V7 node
	 * @param outputFile The XML file generated
	 * @throws JAXBException
	 */
	private static void marshal(Object node, File outputFile) throws JAXBException{
		ClassLoader cl = com.thalesgroup.tusar.v7.ObjectFactory.class.getClassLoader();
		JAXBContext jc = JAXBContext.newInstance("com.thalesgroup.tusar.v7",cl);
		Marshaller m = jc.createMarshaller();
		m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,Boolean.TRUE);
		m.marshal(node, outputFile);
	}

	/**
	 * Creates an XML file from a TUSAR V3 node by calling the function marshal() of JAXB Marshaller
	 * @param node TUSAR V3 node
	 * @param outputFile The XML file generated
	 * @throws JAXBException
	 */
	private static void marshalV3(Object node, File outputFile) throws JAXBException{
		ClassLoader cl = com.thalesgroup.tusar.v3.ObjectFactory.class.getClassLoader();
		JAXBContext jc = JAXBContext.newInstance("com.thalesgroup.tusar.v3",cl);
		Marshaller m = jc.createMarshaller();
		m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,Boolean.TRUE);
		m.marshal(node, outputFile);
	}

	/**
	 * Add the given fileName, measureName and measureValue into the given map
	 * @param measures The map where the given values will be added
	 * @param fileName The name of the file where an analysis has been done
	 * @param measureName The name of the measure to add in the map
	 * @param measureValue The value of the measure to add in the map
	 */
	private static void addMeasure(Map<String, Map<String, String>> measures, String fileName, String measureName, String measureValue){
		Map<String,String> values = measures.get(fileName);
		if (values == null){
			values = new HashMap<String, String>();
			measures.put(fileName, values);
		}
		String value = values.get(measureName);
		if (value == null){
			try{
				Double.parseDouble(measureValue);
				values.put(measureName, measureValue);
			}catch(NumberFormatException e){
				//System.err.println(measureValue + " is not a Number");
			}
		}
		else {
			try{
				Double sum = Double.parseDouble(measureValue) + Double.parseDouble(value);
				values.put(measureName, sum.toString());
			}catch(NumberFormatException e){
				//System.err.println(measureValue + " is not an Number");
			}

		}
	}

	/**
	 * Convert the given CSV lines (obtained with the function extractFromCSV) into a TUSAR file.
	 * @param csvLines CSV lines obtained with the function extractFromCSV
	 * @param outputFile The TUSAR file which will be generated
	 * @param measureFileType The value to put for the attribute called "type" in the generated TUSAR file
	 * @param managedMetrics Metrics that are managed by TUSAR
	 */
	private static void convertToMeasure(List<String[]> csvLines, File outputFile, String measureFileType, Map<String, String> managedMetrics){
		String[] keys = csvLines.get(0);

		Map<Integer, String> indexes = new HashMap<Integer, String>();

		for (int i=0;i<keys.length;i++){
			String metricName = managedMetrics.get(keys[i]);
			if (metricName != null){
				indexes.put(i, metricName);
			}
			else {
				indexes.put(i, keys[i]);
			}
		}

		if (indexes.isEmpty()){
			return;
		}

		//Key : file
		//Value : [MetricName/MetricValue]
		final Map<String, Map<String, String>> measures = new HashMap<String, Map<String, String>>();

		for (int i=1;i<csvLines.size();i++){
			String[] values = csvLines.get(i);
			for (Integer index : indexes.keySet()){
				addMeasure(measures,values[FILE_NAME_INDEX], indexes.get(index), values[index]);
			}
		}

		com.thalesgroup.tusar.v3.Tusar tusarV3 = new com.thalesgroup.tusar.v3.Tusar();
		tusarV3.setVersion("3.0");
		tusarV3.setXmlnsXsi(TUSAR_XMLNS_XSI);

		com.thalesgroup.tusar.measures.v3.MeasuresComplexType measuresComplexType = new com.thalesgroup.tusar.measures.v3.MeasuresComplexType();

		for (String fileName : measures.keySet()){
			com.thalesgroup.tusar.measures.v3.MeasuresComplexType.Resource measuresResource = new com.thalesgroup.tusar.measures.v3.MeasuresComplexType.Resource();
			measuresResource.setType(measureFileType);
			measuresResource.setValue(fileName);
			Map<String, String> measuresCollected = measures.get(fileName);
			for (String measureName : measuresCollected.keySet()){
				com.thalesgroup.tusar.measures.v3.MeasuresComplexType.Resource.Measure measure = new com.thalesgroup.tusar.measures.v3.MeasuresComplexType.Resource.Measure();
				measure.setKey(measureName);
				measure.setValue(measuresCollected.get(measureName));
				measuresResource.getMeasure().add(measure);
			}
			measuresComplexType.getResource().add(measuresResource);
		}
		tusarV3.setMeasures(measuresComplexType);
		try {
			marshalV3(tusarV3, outputFile);
		} catch (JAXBException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Function that parses the given csvLines (obtained with the function extractFromCSV with an Application CSV file) and convert them into TUSAR file
	 * @param csvLines CSV lines obtained with the function extractFromCSV
	 * @param outputFile The TUSAR file which will be generated
	 */
	private static void csvApplicationMetricsParsing(List<String[]> csvLines, File outputFile){
		String[] columns = csvLines.get(0);
		for (String s : columns){
			if (applicationManagedMetrics.get(s) != null){
				convertToMeasure(csvLines,outputFile,"PROJECT",applicationManagedMetrics);
				break;
			}
		}
	}

	/**
	 * Function that parses the given csvLines (obtained with the function extractFromCSV with a Function CSV file) and convert them into TUSAR file
	 * @param csvLines CSV lines obtained with the function extractFromCSV
	 * @param outputFile The TUSAR file which will be generated
	 */
	private static void csvFunctionMetricsParsing(List<String[]> csvLines, File outputFile){
		String[] columns = csvLines.get(0);
		for (String s : columns){
			if (functionManagedMetrics.get(s) != null){
				convertToMeasure(csvLines,outputFile,"FILE",functionManagedMetrics);
				break;
			}
		}
	}

	/**
	 * Function that parses the given csvLines (obtained with the function extractFromCSV with a Module CSV file) and convert them into TUSAR file
	 * @param csvLines CSV lines obtained with the function extractFromCSV
	 * @param outputFile The TUSAR file which will be generated
	 */
	private static void csvModuleMetricsParsing(List<String[]> csvLines, File outputFile){
		String[] columns = csvLines.get(0);
		for (String s : columns){
			if (moduleManagedMetrics.get(s) != null){
				convertToMeasure(csvLines,outputFile,"FILE",moduleManagedMetrics);
				break;
			}
		}
	}

	/**
	 * Function that parses the given csvLines (obtained with the function extractFromCSV with a Package CSV file) and convert them into TUSAR file
	 * @param csvLines CSV lines obtained with the function extractFromCSV
	 * @param outputFile The TUSAR file which will be generated
	 */
	//Not used for the moment
	private static void csvPackageMetricsParsing(List<String[]> csvLines, File outputFile){
		String[] columns = csvLines.get(0);
		for (String s : columns){
			if (packageManagedMetrics.get(s) != null){
				convertToMeasure(csvLines,outputFile,"DIRECTORY",packageManagedMetrics);
				break;
			}
		}
	}

	/**
	 * Function that parses the given csvLines (obtained with the function extractFromCSV with a Class CSV file) and convert them into TUSAR file
	 * @param csvLines CSV lines obtained with the function extractFromCSV
	 * @param outputFile The TUSAR file which will be generated
	 */
	//Not used for the moment
	private static void csvClassMetricsParsing(List<String[]> csvLines, File outputFile){
		String[] columns = csvLines.get(0);
		for (String s : columns){
			if (classManagedMetrics.get(s) != null){
				convertToMeasure(csvLines,outputFile,"FILE",classManagedMetrics);
				break;
			}
		}
	}

	/**
	 * The function to call to parse CSV file generated for a Java project
	 * @param csvFile The CSV file to parse
	 * @param outputFile The TUSAR file which will be generated
	 */
	public static void javaMetricParsing(File csvFile, File outputFile){
		List<String[]> csvLines = extractFromCSV(csvFile);
		csvFunctionMetricsParsing(csvLines, outputFile);
		csvModuleMetricsParsing(csvLines, outputFile);
	}

	/**
	 * The function to call to parse CSV file generated for a C project
	 * @param csvFile The CSV file to parse
	 * @param outputFile The TUSAR file which will be generated
	 */
	public static void cMetricParsing(File csvFile, File outputFile){
		List<String[]> csvLines = extractFromCSV(csvFile);
		csvFunctionMetricsParsing(csvLines, outputFile);
		csvApplicationMetricsParsing(csvLines, outputFile);
	}

	/**
	 * The function to call to parse CSV file generated for a C++ project
	 * @param csvFile The CSV file to parse
	 * @param outputFile The TUSAR file which will be generated
	 */
	public static void cppMetricParsing(File csvFile, File outputFile){
		List<String[]> csvLines = extractFromCSV(csvFile);
		csvFunctionMetricsParsing(csvLines, outputFile);
		csvModuleMetricsParsing(csvLines, outputFile);
	}

	/**
	 * The function to call to parse CSV file generated for an Ada project
	 * @param csvFile The CSV file to parse
	 * @param outputFile The TUSAR file which will be generated
	 */
	public static void adaMetricParsing(File csvFile, File outputFile){
		List<String[]> csvLines = extractFromCSV(csvFile);
		csvFunctionMetricsParsing(csvLines, outputFile);
		csvModuleMetricsParsing(csvLines, outputFile);
	}

	/**
	 * Add the given values into the given map
	 * @param violations The map which contains the violations found during the analysis
	 * @param values The values of the violation currently read
	 */
	private static void addViolation(Map<String,List<String[]>> violations, String[] values, int fileNameIndex){
		List<String[]> violation = violations.get(values[fileNameIndex]);
		if (violation==null){
			violation = new ArrayList<String[]>();
		}
		violation.add(values);
		violations.put(values[fileNameIndex], violation);
	}

	/**
	 * Convert the given CSV lines (obtained with the function extractFromCSV) into a TUSAR violation file.
	 * @param csvLines CSV lines obtained with the function extractFromCSV
	 * @param outputFile The TUSAR file which will be generated
	 */
	private static void convertToViolation(List<String[]> csvLines, File outputFile){
		String[] columnsName = csvLines.get(0);
		Map<String, Integer> indexes = new HashMap<String, Integer>();
		
		for (int i=0;i<columnsName.length;i++){
			String columnName = columnsName[i];
			if (violationsColumnNames.contains(columnName)){
				indexes.put(columnName, i);
			}
		}

		if (indexes.isEmpty() || indexes.size()!=violationsColumnNames.size()){
			return;
		}

		Map<String, List<String[]>> violations = new HashMap<String, List<String[]>>();
		for(int i=1;i<csvLines.size();i++){
			String[] values = csvLines.get(i);
			addViolation(violations, values, indexes.get(FILE_COLUMN_NAME));
		}

		Tusar tusarV7 = new Tusar();
		tusarV7.setVersion(TUSAR_VERSION);
		tusarV7.setXmlnsXsi(TUSAR_XMLNS_XSI);

		ViolationsComplexType violationsComplexType = new ViolationsComplexType();
		for(String fileName : violations.keySet()){
			ViolationsComplexType.File file = new ViolationsComplexType.File();
			file.setPath(fileName);
			for(String[] values : violations.get(fileName)){
				ViolationsComplexType.File.Violation violation = new ViolationsComplexType.File.Violation();
				violation.setKey(replaceDoubleQuotes(values[indexes.get(RULE_COLUMN_NAME)]));
				violation.setLine(values[indexes.get(LINE_COLUMN_NAME)]);
				violation.setMessage(replaceDoubleQuotes(values[indexes.get(DESCRIPTION_COLUMN_NAME)]));
				file.getViolation().add(violation);
			}
			violationsComplexType.getFile().add(file);
		}
		tusarV7.setViolations(violationsComplexType);

		try {
			marshal(tusarV7, outputFile);
		} catch (JAXBException e) {
			e.printStackTrace();
		}
	}

	/**
	 * The function to call to parse RuleChecker Violation CSV file generated by Logiscope
	 * @param csvFile The CSV file to parse
	 * @param output The TUSAR file which will be generated
	 */
	public static void violationParsing(File csvFile, File output){
		List<String[]> csvLines = extractFromCSV(csvFile);
		String[] columnsName = csvLines.get(0);
		if (!Arrays.asList(columnsName).containsAll(violationsColumnNames)){
			return;
		}
		convertToViolation(csvLines, output);
	}

}
